---
title: "Get started with fgeo"
output: github_document
---

This is an R Markdown document (<http://rmarkdown.rstudio.com>). When you click the the green arrow on the top-right of each code chunk, R runs that code.

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  echo = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

This article shows some of the key features of __fgeo__ applied to an exploratory data analysis. For a deeper and general approach to exploratory data analysis see [this book section](http://r4ds.had.co.nz/exploratory-data-analysis.html). A version adapted for ForestGEO is available [here](https://forestgeo.github.io/fgeo/articles/siteonly/eda.html).

## Packages 

In every new R session you need to "open" __fgeo__ with `library`().

```{r}
library(fgeo)
```

## Data

You may load your own data. Here I'll use data from the __fgeo.data__ package -- which comes with __fgeo__.

```{r}
str(fgeo_index_datasets())
```

I'll use a dataset of stems censused in one hectare in the forest plot Luquillo, Puerto Rico (https://forestgeo.si.edu/sites/north-america/luquillo).

```{r}
stem <- luquillo_stem_1ha
str(stem)
```

For a description of the columns see `?data_dictionary`.

```{r}
str(data_dictionary)

cols <- names(stem)
subset(data_dictionary, column %in% cols)
```

This dataset comes with multiple censuses. I'll pick only the latest one.

```{r}
unique(stem$CensusID)

# `pick_top()` with n < 0 from the bottom rank of `var`. See ?pick_top().
stem6 <- pick_top(stem, var = CensusID, n = -1)
unique(stem6$CensusID)
```


## Exploring the distribution of status and tree diameter

Two columns that are commonly useful in ForestGEO datasets are `status` and `dbh` (diameter at breast height). Let's begin by understanding what type of variables they are. For this, base R provides useful functions.

`status` is a categorical variable. 

```{r}
summary(stem6$status)
```

We can count the number of observations in each category with `table()`, then visualize the result with `barplot()`.

```{r barplot}
by_category <- table(stem6$status)
barplot(by_category)
```

`dbh` is a continuous numeric variable.

```{r}
summary(stem6$dbh)
```

(Note the missing values (`NA`'s).)

And we can visualize its distribution with `hist()`. 

```{r histogram}
hist(stem6$dbh)
```

Unfortunately `hist()` dropped missing values silently. But we can better understand how missing values of `dbh` relate to `status` by extracting only the columns `dbh` and `status`, and picking only the rows where `dbh` is missing.

```{r}
dbh_status <- stem6[c("dbh", "status")]
missing <- subset(dbh_status, is.na(dbh))
unique(missing)
```

Another approach is to count missing values.

```{r}
missing <- transform(stem6, na = ifelse(is.na(dbh), TRUE, FALSE))
table(missing$na, missing$status)
```

We learn that `dbh` is missing where a tree is dead (`status = A`) or gone (`status = G`). This makes sense and, depending on the type of analysis we want to do, we may want to keep or remove missing values.

## Determining tree status based on stem status

Now that we understand out data are read to clean it, for example, by picking alive trees only. At ForestGEO, working with `status` is so common that __fgeo__ provides a specialized function.

```R
fgeo_help("status")
```

```{r}
fgeo_funs <- fgeo_index_functions()
subset(fgeo_funs, grepl("status", fun))
```

In `stem6`, the variable `status` records the status of each individual stem. How can we determine the status of a tree based on the status of each of its stems? That is the job of `add_status_tree()`.

```{r}
stem6 <- add_status_tree(stem6, status_a = "A", status_d = "D")
alive_trees <- subset(stem6, status_tree == "A")

# Note that alive trees may have some missing, gone or dead stems
some_cols <- c( "treeID", "status_tree", "stemID", "status")
example_tree <- 46
subset(alive_trees, treeID == example_tree, some_cols)
```

## Picking a `dbh` range

Another very common task when working with ForestGEO data is to pick stems of a particular `dbh` range.

```R
fgeo_help("dbh")
```

```{r}
subset(fgeo_funs, grepl("dbh", fun))
```

Pick stems of 10 mm or more.

```{r}
ten_plus <- pick_dbh_min(alive_trees, 10)
range(ten_plus$dbh, na.rm = TRUE)
```

## Dropping missing values 

Drop missing values of `dbh` with an informative warning.

```{r}
non_missing <- drop_if_na(ten_plus, "dbh")
```

## Calculating abundance

Calculate the total abundance of stems and trees.

```{r}
abundance_stem(non_missing)

abundance_tree(non_missing)
```

Calculate the abundance of trees by species.

```{r}
by_sp <- group_by(non_missing, sp)
n_by_sp <- abundance_tree(by_sp)
n_by_sp
```

Above you saw that `abundance_tree(DATA)` and `abundance_stem(DATA)` generalize to `count_distinct(DATA, stemID)` and `count_distinct(DATA, stemID)`. An even greater generalization is `count()`. __fgeo__ borrows the function `count()` (and some friends) from the [__dplyr__](https://dplyr.tidyverse.org/) package. Today, `dplyr::count()` appears to be the simplest, the most general and powerful tool to count things.  __fgeo__ imports and reexports `dplyr::count()` (and friends) so it's available when you run `library(fgeo)`.

```R
fgeo_help("reexports", package = "fgeo.abundance")
```

## Picking the most abundant species

Which are the three most abundant tree species?

```{r}
top3 <- pick_top(n_by_sp, n, -3)
top3
```

Now we can subset the `alive_trees` of only the `top3` species.

```{r}
picked_stems <- subset(alive_trees, sp %in% top3$sp)
```

## Mapping the distribution of tree species

__fgeo__ includes some functions specialized in mapping ForestGEO's data.

```R
fgeo_help("map")
```

```{r}
subset(fgeo_funs, grepl("map", fun))
```

Map the most abundant species.

```{r species-distribution1}
# luquillo_elevation comes with fgeo
p <- map_sp_elev(picked_stems, elevation = luquillo_elevation, point_size = 1)
p
```

Tweak to focus on the hectare available in the data.

```{r species-distribution2}
p1 <- limit_gx_gy(p, xlim = c(100, 200), ylim = c(400, 500))
p1
```

## Determine species-habitat associations

Let's determine the species-habitat associations using a torus translation test.

```R
fgeo_help("torus")
```


This test should use individual trees not the (potentially multiple) stems of
individual trees. This test only makes sense at the population level. We are
interested in knowing whether or not individuals of a species are aggregated
on a habitat. Multiple stems of an individual do not represent population
level processes but individual level processes. Let's then use a ForestGEO _tree_ table. I'll use `luquillo_tree6_random`, which contains a small sample of randomly chosen trees across the entire plot (see `?`luquillo_tree6_random`). 

```{r}
tree <- luquillo_tree6_random
```

I'll pick alive trees of 10 mm or more (for details see previous sections). The variable `status` of 'tree' tables directly represent the status of each tree (see `?census_description`). I'll focus on trees with status "A" (alive).

```{r}
dbh10plus <- pick_dbh_min(tree, 10)
chosen_trees <- pick_status(dbh10plus, "A")
unique(chosen_trees$status)
```

Note that `tt_test()` is recommended for sufficiently abundant species:

> You should only try to determine the habitat association for sufficiently abundant species - in a 50-ha plot, a minimum abundance of 50 trees/species has been used.

-- `?tt_test()`

```{r}
# Find sufficiently abundant species
by_sp <- group_by(tree, sp)
n_by_sp <- abundance_tree(by_sp)
n_by_sp

n_sp50plus <- subset(n_by_sp, n > 50)
n_sp50plus
```

We'll need habitat data. Or at least elevation data -- with which to create habitat data with `fgeo_habitat()`.

```{r}
# See ?luquillo_habitat
habitat <- luquillo_habitat
# Same
habitat <- fgeo_habitat(luquillo_elevation, gridsize = 20, n = 4)
str(habitat)
```

And now we are ready to run the test.

```{r}
tt <- tt_test(chosen_trees, sp = n_sp50plus$sp, habitat = habitat)
```

The output of `tt_test()` is a list. Large lists are awkward to view -- unless you use `View()` in RStudio.

```R
View(tt)
```

Alternatively, transform the list to a dataframe.

```{r}
tt_df <- to_df(tt)
# Nice view (try also `View()`)
as_tibble(tt_df)
```

## Krige soil data 

Let's Krige soil data.

```R
fgeo_help("krig")
```

__fgeo__ provides a fake soil dataset for examples.

```{r}
str(soil_fake)
```

The data contains multiple soil variables; let's use only two of them.

```{r, message=FALSE}
soil_vars <- c("c", "p")
krig_list <- krig(soil_fake, soil_vars, quiet = TRUE)
```

The output is a nested list, which is awkward to view on the console but you can view it in RStudio with `View()` and summarize it with `summary()`

```{r}
summary(krig_list)
```

Also you can pull a dataframe containing the results of all the soil variables.

```{r}
krig_df <- to_df(krig_list, item = "df")
as_tibble(subset(krig_df,var == "c"))

as_tibble(subset(krig_df, var == "p"))
```

# Demography

```R
fgeo_help("mortality")
```

Demography functions (`recruitment()`, `mortality()` and `growth()`) input two censuses. We'll use small _tree_ tables from census 6 and 7 of Barro Colorado Island.

```{r}
# ?see bciex::bci12t6mini
census1 <- bci12t6mini
census2 <- bci12t7mini
```

`recruitment()`, `mortality()` and `growth()` work similarly. The first and second input are the earlier and later censuses you want to analyze demography on.

```{r}
mortality(census1, census2)
```

All three demography functions provide arguments to split the data by. This is a different approach to do the same job of `group_by()` shown above (here `group_by()` doesn't work).

```{r}
recruitment <- recruitment(census1, census2, split1 = census1$sp)
```

If you "split" the data, the output is a somewhat long list. The best way to view it is with `View()` in RStudio.

```R
View(recruitment)
```
Alternatively use the `*_df()` variants of demography. They output a dataframe that is easier to handle -- it prints particularly well with `as_tibble()`.

```{r}
growth <- growth_df(census1, census2, split1 = census1$sp)
as_tibble(growth)
```

Here too you can use `View()` and search for the species you want. Or you can `subset()` the output and print it to the console.

```{r}
subset(growth, split == "acaldi")
```

If you are interested in only a few species (say less than 5), you may want to spread the species from rows to columns with `spread()` from the __tidyr__ package (see `?tidyr::spread()`).
